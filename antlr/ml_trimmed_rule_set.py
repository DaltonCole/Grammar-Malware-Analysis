import argparse
import os
import io
import sys
from threading import Thread, Lock
import json
import queue
from copy import deepcopy
import numpy as np
from sklearn.model_selection import KFold
from sklearn.metrics import confusion_matrix
from statistics import mean
import progressbar
from math import factorial

from machineLearning import MachineLearning

"""
# NOTE ************************************************
# If number of times each grammar rule isn't useful, try percentage
# of how often the rule is used in the file (ie, normalize the data)

* Use tokens as a rule set as well
########################################################
"""

class MachineLearningTrimmed(MachineLearning):
	def __init__(self, n_grams=4, show_progress_bar=True, save_file='./results.txt'):
		super().__init__(n_grams, show_progress_bar, save_file)

		# Trimmed rules
		self.trimmed_rules = {}

		self.trimmed_rules['DoStatement'.lower()] = 'do_for_while_statement'
		self.trimmed_rules['WhileStatement'.lower()] = 'do_for_while_statement'
		self.trimmed_rules['ForStatement'.lower()] = 'do_for_while_statement'
		self.trimmed_rules['ForVarStatement'.lower()] = 'do_for_while_statement'
		self.trimmed_rules['ForInStatement'.lower()] = 'do_for_while_statement'
		self.trimmed_rules['ForVarInStatement'.lower()] = 'do_for_while_statement'
		self.trimmed_rules['PropertyExpressionAssignment'.lower()] = 'property_rules'
		self.trimmed_rules['ComputedPropertyExpressionAssignment'.lower()] = 'property_rules'
		self.trimmed_rules['PropertyGetter'.lower()] = 'property_rules'
		self.trimmed_rules['PropertySetter'.lower()] = 'property_rules'
		self.trimmed_rules['MethodProperty'.lower()] = 'property_rules'
		self.trimmed_rules['PropertyShorthand'.lower()] = 'property_rules'
		self.trimmed_rules['FunctionExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['ClassExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['MemberIndexExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['MemberDotExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['ArgumentsExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['NewExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['PostIncrementExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['PostDecreaseExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['DeleteExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['VoidExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['TypeofExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['PreIncrementExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['PreDecreaseExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['UnaryPlusExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['UnaryMinusExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['BitNotExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['NotExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['MultiplicativeExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['AdditiveExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['BitShiftExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['RelationalExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['InstanceofExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['InExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['EqualityExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['BitAndExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['BitXOrExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['BitOrExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['LogicalAndExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['LogicalOrExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['TernaryExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['AssignmentExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['AssignmentOperatorExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['TemplateStringExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['ThisExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['IdentifierExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['SuperExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['LiteralExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['ArrayLiteralExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['ObjectLiteralExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['ParenthesizedExpression'.lower()] = 'expression_statement'
		self.trimmed_rules['ArrowFunctionExpression'.lower()] = 'expression_statement'

	def n_gram_setup(self, rule_file='./JavaScript/js_possible_rules.txt'):
		# List of rules
		rules = set()
		self.bad_rules = set()
		# Open rules file
		with open(rule_file, 'r') as f:
			for line in f:
				# Remove rules commented out with '#'
				if not line.startswith('#'):
					line = line.strip().lower()

					if line in self.trimmed_rules:
						line = self.trimmed_rules[line]

					rules.add(line)
				else:
					self.bad_rules.add((line[1:]).strip().lower())

		self.rule_mapping = {}
		for index, rule in enumerate(rules):
			self.rule_mapping[rule] = index

		self.number_of_features = len(rules) ** self.n
		self.number_of_rules = len(rules)

	def _feature_set_mapper_queue(self):
		while True:
			arguments = self.queue.get()
			if arguments is None:
				break
			data = arguments['data']
			row = arguments['row']
			bar = arguments['bar']

			# Clean up data
			data_num = []
			# For each item in data
			for x in data:
				# Convert to lowercase
				x = x.lower()
				# If not an ignored rule
				if x not in self.bad_rules:
					# If rule is being trimmed
					if x in self.trimmed_rules:
						# Changed rule to trimmed rule
						x = self.trimmed_rules[x]
					# Add numerical form of data
					data_num.append(self.rule_mapping[x])

			feature_vector = self._feature_set_mapper(data_num)

			self.mutex.acquire()
			try:
				# Add feature vector to feature matrix
				for col, feature in enumerate(feature_vector):
					self.feature_set[row, col] = feature

				self.count += 1
				if self.show_progress_bar:
					bar.update(self.count)
			finally:
				self.mutex.release()

			self.queue.task_done()

def main():
	save_file = './results/results_trimmed_features.txt'

	if not os.path.exists('./results/'):
		os.makedirs('./results/')
	with open(save_file, 'a') as f:
		f.write('\n-------------------------------------------------------------------------\n')

	for n in range(1, 2):
		# Non-Feature Reduction
		ml = MachineLearningTrimmed(n_grams=n, show_progress_bar=True, save_file=save_file)
		ml.setup(benign_directory='./benign_samples', malicious_directory='./malicious_samples')
	
		#ml.unpickle_it('./pickle')
		ml.decision_tree()
		'''
		ml.random_forest()
		ml.neural_network()
		ml.naive_bayes()
		ml.stochastic_gradient_descent()
		ml.knn()
		ml.svm()


		# Feature Reduction
		ml.feature_selection_do()
	
		ml.decision_tree()
		ml.random_forest()
		ml.neural_network()
		ml.naive_bayes()
		ml.stochastic_gradient_descent()
		ml.knn()
		ml.svm()
		'''

if __name__ == '__main__':
    main()